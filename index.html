<!DOCTYPE html>

<html>

<head>
    <title>Castle with guards</title>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="libs/stats.js"></script>
    <script type="text/javascript" src="libs/dat.gui.js"></script>
    <script type="text/javascript" src="libs/TrackballControls.js"></script>
    <script type="text/javascript" src="libs/ThreeCSG.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="Stats-output">
    </div>
    <!-- div which will hold the output -->
    <div id="WebGL-output">
    </div>

    <script type="text/javascript">
        $(function () {
            // function to repeat textures in order to filled the object
            function createRepeatingTexture(fileName, repeatX, repeatY) {
                var texture = THREE.ImageUtils.loadTexture(fileName);
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(repeatX, repeatY);

                return texture;
            }

            //Self explained
            function createGround() {
                var size = 2000;

                var groundGeometry = new THREE.PlaneGeometry(size, size);

                var groundMaterial = new THREE.MeshBasicMaterial({
                    map: createRepeatingTexture("assets/grass.jpg", 5, 5)
                });

                var ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                ground.rotation.x = -0.5 * Math.PI;

                return ground;
            }


            //Function to create a general road
            function createRoad(length, width, material) {
                var road = new THREE.Mesh(new THREE.PlaneGeometry(length, width), material);
                road.receiveShadow = true;
                road.rotation.x = -0.5 * Math.PI;
                road.position.y = 0.2;

                return road;
            }

            //function to create the surrounding roads of the castle
            function createOuterRoad(positionX, positionY, positionZ, rotationZ, size) {
                var roadMaterial = new THREE.MeshLambertMaterial({
                    map: createRepeatingTexture("assets/road.png", 15, 1)
                });

                var road = createRoad(size, 40, roadMaterial);
                road.rotation.x = Math.PI * 180;
                road.rotation.y = Math.PI * 90;
                road.rotation.z = rotationZ;
                road.position.x = positionX;
                road.position.y = positionY;
                road.position.z = positionZ;

                return road;
            }

            //function to create the inner roads of the castle
            function createInnerRoad() {
                var roadMaterial = new THREE.MeshLambertMaterial({
                    map: createRepeatingTexture("assets/road.png", 15, 1)
                });

                var road = createRoad(1900, 55, roadMaterial);
                road.rotation.x = Math.PI * 180;
                road.rotation.y = Math.PI * 90;
                road.rotation.z = 1.3;
                road.position.z = 1;

                return road;
            }

            function createCastle() {
                var castle = new THREE.Object3D();

                var wallWidth = 210;
                var wallDepth = 13;

                // FUNCAO PARA GERAR A FORMA QUE TEM O CASTELO DE GUIMARAES
                function createWall(wallWidth, wallDepth, back) {

                    var wallHeight = 55;
                    var wallGeometry = new THREE.BoxGeometry(wallWidth, wallHeight, wallDepth);
                    var wallMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/wallnet.jpg", 10, 5)
                    });
                    var floorMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/floor.jpg", 4, 0.6)
                    });


                    var wall = new THREE.Mesh(wallGeometry, new THREE.MeshFaceMaterial([wallMaterial,
                        wallMaterial, floorMaterial, wallMaterial, wallMaterial, wallMaterial
                    ]));
                    wall.castShadow = true;
                    wall.receiveShadow = true;

                    wall.position.y = wallHeight / 2;

                    wall.height = wallHeight; // store height value
                    var wallTextureName = "assets/wall.jpg";
                    var floorTextureName = "assets/floor.jpg";

                    var battlementTexture = createRepeatingTexture("assets/wallnet.jpg", 1, 1);
                    battlementTexture.offset.x = 0.1;

                    var battlementMaterial = new THREE.MeshLambertMaterial({
                        map: battlementTexture
                    });

                    // Put the blocks on top of the walls
                    var battlementWidth = 6;
                    var battlementHeight = 11;

                    var battlementGeometry = new THREE.BoxGeometry(battlementWidth, battlementHeight,
                        battlementWidth);

                    for (var x = 5 + -(wallWidth / 2) + battlementWidth / 2; x < wallWidth / 2 - 5; x +=
                        battlementWidth * 2) {
                        var battlement = new THREE.Mesh(battlementGeometry, battlementMaterial);
                        battlement.castShadow = true;
                        battlement.receiveShadow = true;

                        battlement.position.set(x, wallHeight / 2 + battlementWidth / 2, wallDepth / 2 -
                            battlementWidth / 2);

                        if (back) {
                            battlement.position.set(x, wallHeight / 2 + battlementWidth / 2, -(wallDepth / 2 -
                                battlementWidth / 2));
                        }
                        wall.add(battlement);
                    }

                    return wall;
                }

                // FUNCAO PARA GERAR O PORTAO DO CASTELO
                function createGate(size) {
                    var gateMaterial = new THREE.MeshLambertMaterial({
                        map: THREE.ImageUtils.loadTexture("assets/gate.png"),
                        side: THREE.DoubleSide
                    });
                    var roofMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/roof.jpg", 8, 1.5)
                    });

                    var wallMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/wallnet.jpg", 10, 5)
                    });

                    var wallFloorMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/wallnet.jpg", 10, 1)
                    });

                    var blockMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/wallnet.jpg", 1, 1)
                    });

                    var floorMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/floor.jpg", 2, 2)
                    });

                    var gateBuilding = new THREE.Mesh(new THREE.BoxGeometry(size,
                        55, 35), wallMaterial);

                    gateBuilding.position.y = 55 / 2;

                    // create gate
                    var gateWidth = 24;
                    var gateHeight = 50;
                    var gateGeometry = new THREE.PlaneGeometry(gateWidth, gateHeight);
                    var gate = new THREE.Mesh(gateGeometry, gateMaterial);
                    gate.receiveShadow = true;
                    gate.position.set(0, -2, 35 / 2);
                    gate.name = "gate";

                    // create barriers
                    var barrier = new THREE.Mesh(new THREE.BoxGeometry(size, 6,
                        35), new THREE.MeshFaceMaterial([wallFloorMaterial,
                        wallFloorMaterial, floorMaterial, wallFloorMaterial, wallFloorMaterial,
                        wallFloorMaterial
                    ]));
                    barrier.castShadow = true;
                    barrier.rotation.y = Math.PI;
                    barrier.position.y = 45 / 2 + 8;

                    for (var x = 1 + -(35 / 2) + 7.5 / 2; x < 130 / 2 - 5; x +=
                        7.5 * 2) {
                        var block = new THREE.Mesh(new THREE.BoxGeometry(7.5, 10,
                            5), blockMaterial);
                        block.castShadow = true;
                        block.receiveShadow = true;

                        block.position.set(x - 17.5, 6 / 2 + 7.5 / 2, -10);
                        barrier.add(block);
                    }

                    var leftBlock = new THREE.Mesh(new THREE.BoxGeometry(7.5, 10,
                        5), blockMaterial);
                    leftBlock.position.set(30, 6 / 2 + 7.5 / 2, 6 / 2 + 7.5 / 2 - 4)
                    leftBlock.rotation.y = Math.PI * 0.5;

                    var rightBlock = new THREE.Mesh(new THREE.BoxGeometry(7.5, 10,
                        5), blockMaterial);
                    rightBlock.position.set(-30, 6 / 2 + 7.5 / 2, 6 / 2 + 7.5 / 2 - 4)
                    rightBlock.rotation.y = Math.PI * -0.5;

                    barrier.add(leftBlock);
                    barrier.add(rightBlock);

                    // extract space for the gate from the building
                    var gateMesh = new THREE.Mesh(new THREE.BoxGeometry(gateWidth, gateHeight,
                        35), new THREE.MeshLambertMaterial());
                    gateMesh.position.y = gateHeight / 2;

                    var subtractedBsp = new ThreeBSP(gateBuilding).subtract(new ThreeBSP(gateMesh));

                    gateBuilding = subtractedBsp.toMesh(wallMaterial);
                    gateBuilding.geometry.computeVertexNormals();
                    gateBuilding.castShadow = true;
                    gateBuilding.receiveShadow = true;

                    gateBuilding.add(gate);

                    gateBuilding.add(barrier);

                    return gateBuilding;
                }

                // Funcao para gerar circle towers 
                function createCircleTower(towerHeight, radius) {
                    var towerWallMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/wallnet.jpg", 10, 5)
                    });

                    var tower = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, towerHeight, 20),
                        towerWallMaterial);
                    tower.castShadow = true;
                    tower.receiveShadow = true;

                    tower.position.y = 5;

                    return tower;
                }

                // Funcao para gerar rect towers 
                function createRectTower(width, heigth, depth) {
                    var towerWallMaterial = new THREE.MeshLambertMaterial({
                        map: createRepeatingTexture("assets/wallnet.jpg", 5, 10)
                    });

                    var tower = new THREE.Mesh(new THREE.BoxGeometry(width, heigth, depth),
                        towerWallMaterial);
                    tower.castShadow = true;
                    tower.receiveShadow = true;

                    tower.position.y = 5;

                    return tower;
                }

                // --------------------------------- ESTRUTURA DO CASTELO ---------------------------------
                var leftWall = createWall(wallWidth + 35, wallDepth);
                var rightWall = createWall(wallWidth, wallDepth);
                var frontWallLeftPart = createWall((wallWidth) / 2, wallDepth);
                var frontWallRightPart = createWall((wallWidth) / 3 + 2.5, wallDepth);
                var backTurnedWall = createWall(wallWidth / 2 + 30, wallDepth, true);
                var backWall = createWall(wallWidth + 50, wallDepth, true);

                //FRONT WALLS
                frontWallLeftPart.position.z = wallWidth / 2;
                frontWallLeftPart.position.x = -(wallWidth) / 2 / 2 - 30;
                castle.add(frontWallLeftPart);

                frontWallRightPart.position.z = wallWidth / 2;
                frontWallRightPart.position.x = (wallWidth) / 6 + 35;
                castle.add(frontWallRightPart);

                // LEFT TURNED WALL
                leftWall.rotation.y = -0.3 * Math.PI;
                leftWall.position.x = -wallWidth;
                castle.add(leftWall);

                // BACK TURNED WALL
                backTurnedWall.rotation.y = 0.15 * Math.PI;
                backTurnedWall.position.x = -wallWidth;
                backTurnedWall.position.z = -wallWidth + 70;
                castle.add(backTurnedWall);

                // BACK WALL WITH 3 TOWERS
                backWall.rotation.y = Math.PI * -0.1;
                backWall.position.x = (wallWidth) * -0.1;
                backWall.position.z = -wallWidth + 75;
                castle.add(backWall);

                // RIGHT WALL
                rightWall.rotation.y = 0.5 * Math.PI;
                rightWall.position.x = (wallWidth / 2) - 5;
                castle.add(rightWall);

                //Create gate
                var gate = createGate(70);
                gate.name = "gateBuilding";
                gate.position.z = wallWidth / 2;
                castle.add(gate);

                //Create circle towers
                var rightCircleFrontTower = createCircleTower(85, 18);
                rightCircleFrontTower.position.set(100, 40, 100);
                castle.add(rightCircleFrontTower)

                var leftCircleFrontTower = createCircleTower(85, 18);
                leftCircleFrontTower.position.set(-135, 40, 100);
                castle.add(leftCircleFrontTower)

                var rightCircleBackTower = createCircleTower(85, 20);
                rightCircleBackTower.position.set(100, 40, -100);
                castle.add(rightCircleBackTower)

                var backCircleTower = createCircleTower(85, 20);
                backCircleTower.position.set(-140, 40, -170);
                castle.add(backCircleTower)

                //Create Rect Towers
                var leftCornerTower = createRectTower(25, 100, 30);
                leftCornerTower.position.set(-275, 40, -100);
                castle.add(leftCornerTower)


                // --------------------------------- FIM ESTRUTURA DO CASTELO ---------------------------------

                // FUNCAO PARA GERAR A TORRE DE DENTRO
                // FUNCAO PARA GERAR A PONTE
                // FUNCAO PARA GERAR A BANDEIRA E METE-LA EM CIMA DA TORRE

                return castle;
            }


            function addLight(scene) {
                var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.7);
                hemiLight.position.set(0, 500, 0);

                scene.add(hemiLight);

                var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.castShadow = true;
                dirLight.position.set(265, 150, 265);

                dirLight.shadowMapWidth = 8192;
                dirLight.shadowMapHeight = 8192;

                var lightDist = 800;
                dirLight.shadowCameraLeft = -lightDist;
                dirLight.shadowCameraRight = lightDist;
                dirLight.shadowCameraTop = lightDist;
                dirLight.shadowCameraBottom = -lightDist;

                dirLight.shadowCameraFar = 3500;
                dirLight.shadowBias = 0.001;
                dirLight.shadowDarkness = 0.35;

                scene.add(dirLight);
            }

            var scene = new THREE.Scene();

            scene.fog = new THREE.Fog(0xcccccc, 1000, 1000);

            var renderer = new THREE.WebGLRenderer({
                antialias: true
            });

            renderer.setClearColor(0x9fd2f1, 1.0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer
                .shadowMapEnabled = true;

            var ground = createGround();

            scene.add(ground);

            // add castle
            var castle = createCastle();
            castle.rotation.x = 0.5 * Math.PI;
            castle.rotation.y = -0.25;
            castle
                .position.y = 50;
            castle.position.x = 12;
            ground.add(castle);

            //add the outer roads
            ground.add(createOuterRoad(0, 0.2, 1, 1.325, 1900));
            ground.add(createOuterRoad(0, -160, 1.1, 2.90, 1900));

            addLight(scene);

            // add the output of the renderer to the html element
            $("#WebGL-output").append(renderer.domElement);

            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera
                .position.x = -80;
            camera.position.y = 80;
            camera.position.z = 300;
            camera.lookAt(scene.position);

            // add ability to rotate/move/zoom camera
            var cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
            cameraControls
                .rotateSpeed = 1.0;
            cameraControls.zoomSpeed = 1.0;
            cameraControls.panSpeed = 1.0;
            cameraControls
                .noZoom = false;
            cameraControls.noPan = false;
            cameraControls.staticMoving = true;
            cameraControls
                .dynamicDampingFactor = 0.3;

            render();

            function render() {
                cameraControls.update();

                var goingThroughGates = false;

                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }
        });
    </script>
</body>

</html>