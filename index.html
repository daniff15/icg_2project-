<!DOCTYPE html>

<html>

<head>
    <title>Castle with guards</title>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="libs/stats.js"></script>
    <script type="text/javascript" src="libs/dat.gui.js"></script>
    <script type="text/javascript" src="libs/TrackballControls.js"></script>
    <script type="text/javascript" src="libs/ThreeCSG.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="Stats-output">
    </div>
    <!-- div which will hold the output -->
    <div id="WebGL-output">
    </div>

    <script type="text/javascript">
        $(function () {
            function createRepeatingTexture(fileName, repeatX, repeatY) {
                var texture = THREE.ImageUtils.loadTexture(fileName);
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(repeatX, repeatY);

                return texture;
            }

            function createGround() {
                var size = 2000;

                var groundGeometry = new THREE.PlaneGeometry(size, size);

                var groundMaterial = new THREE.MeshLambertMaterial({
                    map: createRepeatingTexture("assets/grass.jpg", 5, 5)
                });

                var ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.receiveShadow = true;
                ground.rotation.x = -0.5 * Math.PI;

                return ground;
            }

            // function moveKnight(knight, stepIncr) {
            //     if (knight.patrolStatus == "starting") {
            //         knight.position.y -= stepIncr * 100;

            //     } else {
            //         knight.step += stepIncr;

            //         knight.position.x = Math.sin(knight.step) * knight.patrolRadius;
            //         knight.position.y = Math.cos(knight.step) * knight.patrolRadius;

            //         if (knight.rowPos !== undefined) {
            //             knight.position.x += knight.rowPos * 20;
            //             knight.position.y -= knight.colPos * 20;
            //         }

            //         knight.rotateY(-stepIncr);
            //     }
            // }

            function addLight(scene) {
                var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.7);
                hemiLight.position.set(0, 500, 0);

                scene.add(hemiLight);

                var dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.castShadow = true;
                dirLight.position.set(265, 150, -265);

                dirLight.shadowMapWidth = 8192;
                dirLight.shadowMapHeight = 8192;

                var lightDist = 800;
                dirLight.shadowCameraLeft = -lightDist;
                dirLight.shadowCameraRight = lightDist;
                dirLight.shadowCameraTop = lightDist;
                dirLight.shadowCameraBottom = -lightDist;

                dirLight.shadowCameraFar = 3500;
                dirLight.shadowBias = 0.001;
                dirLight.shadowDarkness = 0.35;

                scene.add(dirLight);
            }

            // SHOW FPS FUNCTION
            // function initStats() {
            //     var stats = new Stats();

            //     stats.setMode(0); // 0: fps, 1: ms

            //     // Align top-left
            //     stats.domElement.style.position = 'absolute';
            //     stats.domElement.style.left = '0px';
            //     stats.domElement.style.top = '0px';

            //     $("#Stats-output").append(stats.domElement);

            //     return stats;
            // }

            var scene = new THREE.Scene();

            scene.fog = new THREE.Fog(0xcccccc, 400, 900);

            var renderer = new THREE.WebGLRenderer({
                antialias: true
            });

            renderer.setClearColor(0x9fd2f1, 1.0);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMapEnabled = true;

            var ground = createGround();

            scene.add(ground);

            // // add castle

            // var castle = createCastle();

            // castle.rotation.x = 0.5 * Math.PI;

            // ground.add(castle);

            addLight(scene);

            // add the output of the renderer to the html element
            $("#WebGL-output").append(renderer.domElement);

            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.x = -70;
            camera.position.y = 80;
            camera.position.z = 260;
            camera.lookAt(scene.position);

            // add ability to rotate/move/zoom camera
            var cameraControls = new THREE.TrackballControls(camera, renderer.domElement);
            cameraControls.rotateSpeed = 1.0;
            cameraControls.zoomSpeed = 1.0;
            cameraControls.panSpeed = 1.0;
            cameraControls.noZoom = false;
            cameraControls.noPan = false;
            cameraControls.staticMoving = true;
            cameraControls.dynamicDampingFactor = 0.3;

            // var gui = new dat.GUI();
            // gui.add(new function () {
            //     this.camera1 = function () {
            //         cameraControls.reset();

            //         camera.position.x = -70;
            //         camera.position.y = 80;
            //         camera.position.z = 260;

            //         cameraControls.target = scene.position.clone();
            //     }
            // }, 'camera1');
            // gui.add(new function () {
            //     this.camera2 = function () {
            //         cameraControls.reset();

            //         camera.position.x = -90;
            //         camera.position.y = 80;
            //         camera.position.z = -50;

            //         cameraControls.target = castle.getObjectByName("gateBuilding").position.clone();
            //     }
            // }, 'camera2');
            // gui.add(new function () {
            //     this.camera3 = function () {
            //         cameraControls.reset();

            //         camera.position.x = 120;
            //         camera.position.y = 210;
            //         camera.position.z = -240;

            //         cameraControls.target = castle.position.clone();
            //     }
            // }, 'camera3');

            // var stats = initStats();

            render();

            function render() {
                //stats.update();

                cameraControls.update();

                var goingThroughGates = false;

                // knights.forEach(function (knight) {
                //     moveKnight(knight, 0.002);

                //     if (knight.patrolStatus == "starting") {
                //         if (castle.castleSize / 2 - 5 < Math.abs(knight.position.y)) {
                //             goingThroughGates = true;
                //         }
                //         if (castle.castleSize / 2 + 50 < Math.abs(knight.position.y)) {
                //             knight.patrolStatus = "patrol";

                //             knight.rotateY(-0.5 * Math.PI);
                //         }
                //     }
                // });

                // var gate = castle.getObjectByName("gate", true);
                // gate.visible = !goingThroughGates;

                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }



            // fill UV coordinates (works only for planar surface), code from http://stackoverflow.com/questions/20774648/three-js-generate-uv-coordinate
            function assignUvs(geometry) {
                geometry.computeBoundingBox();

                var max = geometry.boundingBox.max;
                var min = geometry.boundingBox.min;

                var offset = new THREE.Vector2(0 - min.x, 0 - min.y);
                var range = new THREE.Vector2(max.x - min.x, max.y - min.y);

                geometry.faceVertexUvs[0] = [];
                var faces = geometry.faces;

                var i;
                for (i = 0; i < geometry.faces.length; i++) {

                    var v1 = geometry.vertices[faces[i].a];
                    var v2 = geometry.vertices[faces[i].b];
                    var v3 = geometry.vertices[faces[i].c];

                    geometry.faceVertexUvs[0].push([
                        new THREE.Vector2((v1.x + offset.x) / range.x, (v1.y + offset.y) / range.y),
                        new THREE.Vector2((v2.x + offset.x) / range.x, (v2.y + offset.y) / range.y),
                        new THREE.Vector2((v3.x + offset.x) / range.x, (v3.y + offset.y) / range.y)
                    ]);
                }

                geometry.uvsNeedUpdate = true;
            }
        });
    </script>
</body>

</html>